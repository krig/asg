#!/usr/bin/env python
"""asg

Usage:
  asg [-v] [--output=<dir>]
      [--serve|--watch] [--port=<port>]
      [<config>]

Options:
  -h --help          Show this screen.
  --version          Show version.
  -v --verbose       Print debug output.
  -o --output=<dir>  Output directory [default: output/].
  -s --serve         Launch server.
  -w --watch         Launch server, watch content for changes.
  -p --port=<port>   Server port [default: 4763].
"""
from docopt import docopt
import os
import re
import sys
import shutil
import dateutil
import yaml
import jinja2
import logging
from glob import glob
from asglib import asciidocapi
import markdown
FORMAT = '%(levelname)-8s %(asctime)-15s: %(message)s'
logging.basicConfig(format=FORMAT)
log = logging.getLogger(__name__)


def modified(src, dst):
    if os.path.exists(dst):
        return os.path.getmtime(src) > os.path.getmtime(dst)
    return True


def update_file(src, dst):
    if modified(src, dst):
        log.debug("+f %s -> %s" % (src, dst))
        shutil.copy2(src, os.path.dirname(dst))
    else:
        log.debug("*f %s -> %s" % (src, dst))


def makedir(tgt):
    if not os.path.isdir(tgt):
        log.debug("+d %s" % (tgt))
        os.mkdir(tgt)
    else:
        log.debug("*d %s" % (tgt))



class Asg(object):
    def __init__(self, args, config):
        self._md = markdown.Markdown(extensions=['sane_lists', 'smarty'], output_format='html5')

        self.parsers = {
            'markdown': self.parse_markdown,
            'asciidoc': self.parse_asciidoc,
            'template': self.parse_template
        }
        self.filetypes = {
            '.md': 'markdown',
            '.txt': 'asciidoc',
            '.html': 'template',
            '.xml': 'template'
        }
        self.categories = []
        self.tags = []

        self.args = args
        for key, value in config.iteritems():
            if key == 'filetypes':
                for ft, tgt in value.iteritems():
                    if tgt not in self.parsers:
                        raise ValueError("Unknown parsers for %s: %s" % (ft, tgt))
                    self.filetypes[ft] = tgt
            setattr(self, key, value)
        self.output = args['--output']

        self.source_items = []
        self.meta_items = []

    def build(self):
        makedir(self.output)

        for thing in self.static:
            self.copy_static(thing)

        for thing in self.content:
            self.parse_content(thing)

        for item in self.source_items:
            self.process_item(item)

        for item in self.meta_items:
            self.process_item(item)

        for category in self.categories:
            pass # process_item(CategoryItem(category))

        for tag in self.tags:
            pass # process_item(TagItem(tag))

    def _site(self):
        return {
            'title': getattr(self, 'title', 'Site'),
            'lang': getattr(self, 'lang', 'en'),
            'charset': getattr(self, 'charset', 'utf-8'),
            'url': getattr(self, 'url', 'localhost:%s' % (self.args['--port'])),
            'author': getattr(self, 'author', ''),
            'email': getattr(self, 'email', ''),
            'description': getattr(self, 'description', ''),
            'uuid': getattr(self, 'uuid', getattr(self, 'title', 'Site')),
            'favicon': getattr(self, 'favicon', '/favicon.ico'),
            'feedurl': getattr(self, 'feedurl', '/atom.xml'),
            'feedtype': getattr(self, 'feedtype', 'application/atom+xml')
        }

    def parse_content(self, content):
        if os.path.isdir(content):
            pfxlen = len(content)
            for root, subdirs, files in os.walk(content, followlinks=True):
                tgtdir = root[pfxlen:]
                log.debug("? %s, %s, %s, %s" % (root, tgtdir, subdirs, files))
                for f in files:
                    self.parse_file(os.path.join(root, f),
                                    os.path.join(tgtdir, f))
        else:
            self.parse_file(content, content)

    def _dir(self, path):
        makedir(os.path.join(self.output, path))

    def _update(self, src, dst):
        update_file(src, os.path.join(self.output, dst))

    def copy_static(self, static):
        if os.path.isdir(static):
            pfxlen = len(static)
            for root, subdirs, files in os.walk(static, followlinks=True):
                tgtdir = root[pfxlen:]
                if tgtdir:
                    self._dir(tgtdir)
                for f in files:
                    self._update(os.path.join(root, f),
                                 os.path.join(tgtdir, f))
        else:
            path, name = os.path.split(static)
            if path:
                self._dir(path)
            self._update(static, static)

    def parse_file(self, srcpath, dstpath):
        log.debug("?f %s -> %s" % (srcpath, dstpath))
        _, ext = os.path.splitext(srcpath)
        if ext not in self.filetypes:
            raise ValueError("No parser for: %s" % (ext))
        log.debug("!p %s :: %s" % (srcpath, self.filetypes[ext]))
        self.parsers[self.filetypes[ext]](srcpath, dstpath)

    def read_fm(self, path):
        """
        Reads and parses front matter from file in path.
        If there is no front matter, returns {}, <content>
        Else returns frontmatter, <content>
        """
        fm = []
        content = []
        fmdone = False
        with open(path) as f:
            for line in f.readlines():
                while line and line[-1] in ('\n', '\r'):
                    line = line[:-1]
                if not fmdone:
                    if line.strip() == "---":
                        fmdone = True
                    else:
                        fm.append(line.strip())
                else:
                    content.append(line)
        if fmdone:
            return yaml.load('\n'.join(fm)), '\n'.join(content)
        else:
            return {}, '\n'.join(fm)

    def read_asciidoc_fm(self, path):
        """
        Asciidoc front-matter is of a different format:
        <title>
        =======
        :<key>: <value>

        until a blank line

        Not exactly true, but...
        """
        fm = []
        content = []
        fmdone = False
        with open(path) as f:
            for line in f.readlines():
                while line and line[-1] in ('\n', '\r'):
                    line = line[:-1]
                if not fmdone:
                    if line.strip() == "":
                        fmdone = True
                    else:
                        fm.append(line.strip())
                else:
                    content.append(line)
        if fmdone:
            ret = {}
            ret['title'] = fm[0].strip()
            if set(fm[1].strip()) != '=':
                raise ValueError("Document has no title: %s" % (path))
            for line in fm[2:]:
                m = re.match(r"^:(.+):(.+)$", line)
                if not m:
                    raise ValueError("Unexpected %s" % (line))
                ret[m.group(1).lower()] = m.group(2).strip()
            return ret, '\n'.join(content)
        else:
            return {}, '\n'.join(fm)

    def _make_slug(self, srcpath, frontmatter, dstpath):
        "returns slug, dest"
        log.debug("make_slug: %s, %s" % (frontmatter, dstpath))
        slug, dest = frontmatter.get('slug'), frontmatter.get('url')
        if not slug:
            slug = os.path.splitext(os.path.basename(srcpath))[0].replace(' ', '_')
        if not dest:
            dest = os.path.splitext(os.path.basename(dstpath))[0] + '/index.html'
        return slug, dest

    def parse_markdown(self, srcpath, dstpath):
        fm, content = self.read_fm(srcpath)
        slug, dest = self._make_slug(srcpath, fm, dstpath)
        # calculate destination
        # if destination is up to date, skip
        if not modified(srcpath, dest):
            log.debug("*f: %s -> %s" % (srcpath, dest))
            return
        fm['slug'] = slug
        fm['dest'] = dest
        fm['content'] = content
        fm['srcpath'] = srcpath
        fm['dstpath'] = dstpath
        fm['processor'] = self.process_markdown
        self.source_items.append(fm)

    def parse_asciidoc(self, srcpath, dstpath):
        fm, content = self.read_asciidoc_fm(srcpath)
        slug, dest = self._make_slug(srcpath, fm, dstpath)
        if not modified(srcpath, dest):
            log.debug("*f: %s -> %s" % (srcpath, dest))
            return
        fm['slug'] = slug
        fm['dest'] = dest
        fm['content'] = content
        fm['srcpath'] = srcpath
        fm['dstpath'] = dstpath
        fm['processor'] = self.process_asciidoc
        self.meta_items.append(fm)

    def parse_template(self, srcpath, dstpath):
        fm, content = self.read_fm(srcpath)
        slug, dest = self._make_slug(srcpath, fm, dstpath)
        if not modified(srcpath, dest):
            log.debug("*f: %s -> %s" % (srcpath, dest))
            return
        fm['slug'] = slug
        fm['dest'] = dest
        fm['content'] = content
        fm['srcpath'] = srcpath
        fm['dstpath'] = dstpath
        fm['processor'] = self.process_template
        self.meta_items.append(fm)

    def process_item(self, item):
        log.debug("process item: %s" % (str(item)))

    def process_markdown(self):
        pass

    def process_asciidoc(self):
        pass

    def process_template(self):
        pass


def main(args):
    if args['<config>'] is None:
        args['<config>'] = './config.yaml'
    if args['--verbose']:
        log.setLevel(logging.DEBUG)
    log.debug("%s" % ', '.join('%s=%s' % (k, v) for k, v in args.iteritems()))
    config = yaml.load(open(args['<config>']))
    asg = Asg(args, config)
    asg.build()
    if args['--serve']:
        import SimpleHTTPServer
        import SocketServer
        os.chdir(args['--output'])
        PORT = int(args['--port'])
        print "Serving on 0.0.0.0:%s" % (PORT)
        handler = SimpleHTTPServer.SimpleHTTPRequestHandler
        httpd = SocketServer.TCPServer(("", PORT), handler)
        httpd.serve_forever()

if __name__ == "__main__":
    args = docopt(__doc__, version="asg 0.1")
    main(args)
